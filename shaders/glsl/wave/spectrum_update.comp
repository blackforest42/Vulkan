#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rg32f) uniform readonly image2D spectrumH0;
layout(binding = 1, rg32f) uniform writeonly image2D spectrumHt;

layout(std140, binding = 2) uniform SpectrumParams {
    vec4 wind;      // xy = direction, z = speed, w = amplitude
    vec4 spectrum;  // x = gravity, y = depth, z = fetch, w = gamma
    vec4 jonswap;   // x = alpha, y = peakOmega, z = sigmaA, w = sigmaB
    vec4 time;      // x = time
} params;

const float PI = 3.14159265359;
const int N = 512;

vec2 complexMul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

void main() {
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    if (texCoord.x >= N || texCoord.y >= N) {
        return;
    }

    vec2 k = (vec2(texCoord) - vec2(N) * 0.5) * (2.0 * PI / float(N));
    float kLen = length(k);
    float gravity = params.spectrum.x;
    float depth = params.spectrum.y;
    float omega = sqrt(gravity * kLen * tanh(kLen * depth));

    vec2 h0 = imageLoad(spectrumH0, texCoord).xy;
    ivec2 mirrored = ivec2((N - texCoord.x) % N, (N - texCoord.y) % N);
    vec2 h0m = imageLoad(spectrumH0, mirrored).xy;
    vec2 h0Conj = vec2(h0m.x, -h0m.y);

    float t = params.time.x;
    vec2 expPos = vec2(cos(omega * t), sin(omega * t));
    vec2 expNeg = vec2(expPos.x, -expPos.y);

    vec2 ht = complexMul(h0, expPos) + complexMul(h0Conj, expNeg);
    imageStore(spectrumHt, texCoord, vec4(ht, 0.0, 0.0));
}
