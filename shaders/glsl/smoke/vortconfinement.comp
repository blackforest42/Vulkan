#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Texture index mappings
// 0 velocity
// 1 pressure
// 2 divergence
// 3 vorticity
// 4 density
// 5 temperature
layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout(binding = 2) uniform SimUBO {
    ivec3 gridSize;
    float timeStep;
    float vorticityStrength;
} ubo;

float getVorticityMagnitude(ivec3 coord) {
    // magnitude is stored in w channel from previous compute
    return texelFetch(readOnlyTexs[3], coord, 0).w;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);

    // Temp vorticity from previous compute
    vec3 omega = texelFetch(readOnlyTexs[3], coord, 0).xyz;

    // Compute gradient of vorticity magnitude
    float wL = getVorticityMagnitude(coord - ivec3(1, 0, 0));
    float wR = getVorticityMagnitude(coord + ivec3(1, 0, 0));
    float wD = getVorticityMagnitude(coord - ivec3(0, 1, 0));
    float wU = getVorticityMagnitude(coord + ivec3(0, 1, 0));
    float wB = getVorticityMagnitude(coord - ivec3(0, 0, 1));
    float wF = getVorticityMagnitude(coord + ivec3(0, 0, 1));

    vec3 eta = vec3(wR - wL, wU - wD, wF - wB) * 0.5;
    eta = normalize(eta + vec3(0.001));

    // Confinement force: f = e * h * (N x w)
    vec3 force = ubo.timeStep * ubo.vorticityStrength * cross(eta, omega);

    vec4 vel = texelFetch(readOnlyTexs[0], coord, 0);
    vel.xyz += force;
    imageStore(writeOnlyTexs[0], coord, vel);
}