#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout(binding = 2) uniform SimParams {
    ivec3 gridSize;
} ubo;

// Texture index mappings
// 0 velocity
// 1 pressure
// 2 divergence
// 3 vorticity
// 4 density
// 5 temperature

bool isBoundary(ivec3 coord) {
    if (any(greaterThan(coord, ubo.gridSize - 1)) || any(lessThan(coord, ivec3(0)))) {
        return true;
    }
    return false;
}

float getPressure(ivec3 coord) {
    return texelFetch(readOnlyTexs[1], coord, 0).r;
}

vec3 getVelocity(ivec3 coord) {
    return texelFetch(readOnlyTexs[0], coord, 0).xyz;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);

    const ivec3 LEFT =  coord - ivec3(1, 0, 0);
    const ivec3 RIGHT=  coord + ivec3(1, 0, 0);
    const ivec3 DOWN =  coord - ivec3(0, 1, 0);
    const ivec3 UP   =  coord + ivec3(0, 1, 0);
    const ivec3 BACK =  coord - ivec3(0, 0, 1);
    const ivec3 FORW =  coord + ivec3(0, 0, 1);

    // Compute pressure gradient
    float pL = getPressure(LEFT);
    float pR = getPressure(RIGHT);
    float pD = getPressure(DOWN);
    float pU = getPressure(UP);
    float pB = getPressure(BACK);
    float pF = getPressure(FORW);

    // Divide by two for derivative between 2 cells
    // e.g. (f(x + 1) - f(x)) / 2
    vec3 gradP = vec3(pR - pL, pU - pD, pF - pB) * 0.5f;

    // Subtract gradient
    vec3 vel = texelFetch(readOnlyTexs[0], coord, 0).xyz;
    vel.xyz -= gradP;

    vec3 vLeft  = isBoundary(LEFT)  ? vec3(0) : getVelocity(LEFT);
    vec3 vRight = isBoundary(RIGHT) ? vec3(0) : getVelocity(RIGHT);
    vec3 vDown  = isBoundary(DOWN)  ? vec3(0) : getVelocity(DOWN);
    vec3 vUp    = isBoundary(UP)    ? vec3(0) : getVelocity(UP);
    vec3 vBack  = isBoundary(BACK)  ? vec3(0) : getVelocity(BACK);
    vec3 vForw  = isBoundary(FORW)  ? vec3(0) : getVelocity(FORW);

    vec3 vMask;
    vMask.x = (isBoundary(LEFT)  || isBoundary(RIGHT)) ? 0 : 1;
    vMask.y = (isBoundary(UP)    || isBoundary(DOWN)) ? 0 : 1;
    vMask.z = (isBoundary(BACK)  || isBoundary(FORW)) ? 0 : 1;

    vel = (vMask * vel);

    imageStore(writeOnlyTexs[0], coord, vec4(vel, 1));
}