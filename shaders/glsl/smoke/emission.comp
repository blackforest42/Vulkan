#version 450
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout(binding = 2) uniform EmissionUBO {
    ivec3 gridSize;
    vec3 sourceCenter;
    float sourceRadius;
    float deltaTime;
    float time;
} ubo;

const float PI = 3.141592653589793238462643383279502884197;

// Texture index mappings
// 0 velocity
// 1 pressure
// 2 divergence
// 3 vorticity
// 4 density
// 5 temperature

bool isBoundary(ivec3 coord) {
    if (any(greaterThanEqual(coord, ubo.gridSize - 1)) || any(lessThanEqual(coord, ivec3(0)))) {
        return true;
    }
    return false;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);
    if (isBoundary(coord)) {
        return;
    }

    vec3 pos = vec3(coord) + 0.5;
    float distSq = dot(pos - ubo.sourceCenter, pos - ubo.sourceCenter);
    float radiusSq = ubo.sourceRadius * ubo.sourceRadius;

    // We only calculate if within radius to save cycles and prevent infinite tails
    if (distSq < radiusSq) {
        // Gaussian Falloff: exp(-dist^2 / (2 * sigma^2))
        float sigmaSq2 = radiusSq / 4.5;
        float falloff = exp(-distSq / sigmaSq2);

        // Add density (accumulate)
        float saturation = 0.78f;
        float density = 1.5f*(((sin(ubo.time * 3)*0.5f + 0.5f))*saturation + (1.0f-saturation));
        imageStore(writeOnlyTexs[4], coord, vec4(density));

        // Set temperature
        float currentTemp = texelFetch(readOnlyTexs[5], coord, 0).r;
        float emissionTemp = 10.f * falloff;
        float newTemp = max(currentTemp, emissionTemp);
        imageStore(writeOnlyTexs[5], coord, vec4(newTemp));

        // Add velocity
        float impulseStrength = 0.8f;
        float impulseDx = 0.5f * impulseStrength;
        float impulseDy = 0.5f * impulseStrength;
        float impulseDz = 0.8f * impulseStrength;
        imageStore(writeOnlyTexs[0], coord, vec4(impulseDx, impulseDy, impulseDz, 1.));
    }
}
