#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Texture index mappings
// 0 velocity
// 1 pressure
// 2 divergence
// 3 vorticity
// 4 density
// 5 temperature
layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout(binding = 2) uniform EmissionParams {
    ivec3 gridSize;
    vec3 sourceCenter;
    float sourceRadius;
    float emissionRate;      // Density added per second
    float emissionTemp;      // Temperature of emitted smoke
    float ambientTemp;
    float deltaTime;
} ubo;

bool isSolid(ivec3 coord) {
    if (any(lessThan(coord, ivec3(0))) || 
        any(greaterThanEqual(coord, ubo.gridSize))) {
        return true;
    }
    return false;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(coord, ubo.gridSize))) return;
    
    if (isSolid(coord)) return;
    
    vec3 pos = vec3(coord) + 0.5;
    float dist = length(pos - ubo.sourceCenter);
    
    if (dist < ubo.sourceRadius) {
        // Smooth falloff
        float t = 1.0 - (dist / ubo.sourceRadius);
        float falloff = t * t;
        
        // Add density (accumulate, don't replace)
        float currentDensity = texture(readOnlyTexs[4], coord).r;
        float addedDensity = ubo.emissionRate * ubo.deltaTime * falloff;
        float newDensity = min(currentDensity + addedDensity, 2.0);  // Cap at 2.0
        imageStore(writeOnlyTexs[4], coord, vec4(newDensity));
        
        // Set temperature (take maximum of current and emission temp)
        float currentTemp = texture(readOnlyTexs[5], coord).r;
        float emissionTemp = ubo.ambientTemp + ubo.emissionTemp * falloff;
        float newTemp = max(currentTemp, emissionTemp);
        imageStore(writeOnlyTexs[5], coord, vec4(newTemp));
    }
}