#version 450
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout(binding = 2) uniform EmissionUBO {
    ivec3 gridSize;
    vec3 sourceCenter;
    float sourceRadius;
    float timeStep;
    float time;
} ubo;

const float PI = 3.141592653589793238462643383279502884197;

// Texture index mappings
// 0 velocity
// 1 pressure
// 2 divergence
// 3 vorticity
// 4 density
// 5 temperature

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);

    vec3 pos = vec3(coord);
    float distSq = dot(pos - ubo.sourceCenter, pos - ubo.sourceCenter);
    float radiusSq = ubo.sourceRadius * ubo.sourceRadius;

    // We only calculate if within radius to save cycles and prevent infinite tails
    if (distSq < radiusSq) {
        // Gaussian Falloff: exp(-dist^2 / (2 * sigma^2))
        float sigmaSq2 = radiusSq / 4.5;
        float falloff = exp(-distSq / sigmaSq2);

        // Add density (accumulate)
        float saturation = 0.78f;
        // Creates a time varying "pulse"
        float density = 1.5f * (((sin(ubo.time * 3.0f)* 0.5f + 0.5f))
            * saturation + (1.0f - saturation));
        imageStore(writeOnlyTexs[4], coord, vec4(density));

        // Add velocity
        float impulseStrength = 0.8f;
        float impulseDx = 0.0f * impulseStrength;
        float impulseDy = 0.8f * impulseStrength;
        float impulseDz = 0.0f * impulseStrength;
        imageStore(writeOnlyTexs[0], coord, vec4(impulseDx, impulseDy, impulseDz, 1.));
    }
}
