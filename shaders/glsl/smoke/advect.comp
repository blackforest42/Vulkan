#version 450
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Texture index mappings
// 0 velocity
// 1 pressure
// 2 divergence
// 3 vorticity
// 4 density
// 5 temperature
layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout(binding = 2) uniform AdvectionUBO {
    ivec3 gridSize;
    vec3 invGridSize;
    float timeStep;
    float dissipation;
} ubo;

bool isBoundary(vec3 uvw);
vec3 getAdvectedPos(const vec3 uvw);
void advectScalarField(vec3 uvw, const int idx);
void advectVelocityField(vec3 uvw);

vec3 convertToUvCoord(ivec3 coord) {
    vec3 a = 0.5f * ubo.invGridSize;
    return (1.f * coord / ubo.gridSize) + a;
}

ivec3 convertToGridCoord(vec3 uvw) {
    vec3 a = 0.5f * ubo.invGridSize;
    return ivec3((uvw - a) * ubo.gridSize);
}

void advectScalarField(vec3 uvw, const int idx) {
    ivec3 coord = ivec3(gl_GlobalInvocationID);
    if (texelFetch(readOnlyTexs[idx], coord, 0).r == 0) {
	    imageStore(writeOnlyTexs[idx], coord, vec4(0));
    }

    vec3 nuvw = getAdvectedPos(uvw);
    float scalar = texture(readOnlyTexs[idx], nuvw).r;
	imageStore(writeOnlyTexs[idx], coord, vec4(scalar));
}

void advectVelocityField(vec3 uvw) {
    vec3 nuvw = getAdvectedPos(uvw);
    ivec3 coord = convertToGridCoord(uvw);
    vec4 vel = texture(readOnlyTexs[0], nuvw);
	imageStore(writeOnlyTexs[0], coord, vel);
}

vec3 getAdvectedPos(const vec3 uvw) {
    // Backtrace to find where this particle came from
    vec3 vel = texture(readOnlyTexs[0], uvw).xyz;
    return uvw - vel * ubo.timeStep;
}

bool isBoundary(ivec3 coord) {
    if (any(greaterThanEqual(coord, ubo.gridSize - 1)) || any(lessThanEqual(coord, ivec3(0)))) {
        return true;
    }
    return false;
}


void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);
    vec3 uvw = convertToUvCoord(coord);

    // advect velocity (with itself)
    advectVelocityField(uvw);

    // advect density with velocity
    advectScalarField(uvw, 4);

    // advect temperature (with velocity)
    advectScalarField(uvw, 5);
}