#version 450
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout(binding = 2) uniform AdvectionParams {
    ivec3 gridSize;
    float deltaTime;
    float dissipation;
} ubo;

// Standard semi-Lagrangian backtrace
vec3 backtrace(vec3 pos, vec3 velocity, float dt) {
    return pos - velocity * dt;
}

// Trilinear interpolation
float sampleField(sampler3D tex, vec3 pos) {
    vec3 uvw = (pos + 0.5) / vec3(ubo.gridSize);
    uvw = clamp(uvw, vec3(0.0), vec3(1.0));
    return texture(tex, uvw).r;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);
    if (any(equal(coord, ubo.gridSize - 1)) || any(equal(coord, ivec3(0))))
        return;
    
    vec3 pos = vec3(coord) + 0.5;
    vec3 velocity = texelFetch(readOnlyTexs[0], coord, 0).xyz;
    
    // Step 1: Forward advection (standard semi-Lagrangian)
    vec3 backPos = backtrace(pos, velocity, ubo.deltaTime);
    float phi_n_plus_1 = sampleField(readOnlyTexs[4], backPos);
    
    // Step 2: Backward advection (reverse time)
    vec3 forwardPos = backtrace(backPos, -velocity, -ubo.deltaTime);
    float phi_n_estimate = sampleField(readOnlyTexs[4], forwardPos);
    
    // Step 3: Error correction
    float phi_n = texelFetch(readOnlyTexs[4], coord, 0).r;
    float error = phi_n - phi_n_estimate;
    float phi_corrected = phi_n_plus_1 + 0.5 * error;
    
    // Step 4: Clamp to prevent overshoots (important!)
    // Sample neighbors to find min/max bounds
    float minVal = phi_n_plus_1;
    float maxVal = phi_n_plus_1;
    
    for (int z = -1; z <= 1; z++) {
        for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
                ivec3 neighbor = coord + ivec3(x, y, z);
                if (any(lessThan(neighbor, ivec3(0))) || 
                    any(greaterThanEqual(neighbor, ubo.gridSize))) continue;
                
                float neighborVal = texelFetch(readOnlyTexs[4], neighbor, 0).r;
                minVal = min(minVal, neighborVal);
                maxVal = max(maxVal, neighborVal);
            }
        }
    }
    
    // Clamp corrected value to local extrema
    phi_corrected = clamp(phi_corrected, minVal, maxVal);
    
    // Apply dissipation
    phi_corrected *= (1.0 - ubo.dissipation * ubo.deltaTime);
    
    imageStore(writeOnlyTexs[4], coord, vec4(phi_corrected));
}