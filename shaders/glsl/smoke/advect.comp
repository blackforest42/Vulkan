#version 450
#extension GL_EXT_nonuniform_qualifier : enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Texture index mappings
// 0 velocity
// 1 pressure
// 2 divergence
// 3 vorticity
// 4 density
// 5 temperature
layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout (binding = 2) uniform SimParams {
    ivec3 gridSize;
    float deltaTime;
    float dissipation;
} params;

bool isSolid(ivec3 coord) {
    if (any(equal(coord, params.gridSize - 1)) || any(equal(coord, ivec3(0)))) {
        return true;
    }
    return false;
}

void advectFieldByIndex(const int idx) {
    ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);
    if (any(greaterThanEqual(coord, params.gridSize))) return;
    
    // Solid cells remain zero
    if (isSolid(coord)) {
        imageStore(writeOnlyTexs[idx], coord, vec4(0.0));
        return;
    }
    
    // Backtrace to find where this particle came from
    vec3 pos = vec3(coord) + 0.5;
    vec3 vel = texelFetch(readOnlyTexs[0], coord, 0).xyz;
    vec3 prevPos = pos - vel * params.deltaTime;
    
    // Convert to texture coordinates [0, 1]
    vec3 uvw = (prevPos + 0.5) / vec3(params.gridSize);
    uvw = clamp(uvw, vec3(0.0), vec3(1.0));
    
    // Sample field at previous position using hardware trilinear filtering
    vec4 value = texture(readOnlyTexs[idx], uvw);
    
    // Apply dissipation
    value *= (1.0 - params.dissipation * params.deltaTime);
    
    imageStore(writeOnlyTexs[idx], coord, vec4(value));
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);
    if (any(equal(coord, params.gridSize - 1)) || any(equal(coord, ivec3(0)))) return;
    // for debugging
    // imageStore(writeOnlyTexs[0], coord, vec4(coord / 128.f, .5f));

    // advect velocity (with itself)
    advectFieldByIndex(0);

    // advect density with velocity
    advectFieldByIndex(4);

    // advect temperature (with velocity)
    advectFieldByIndex(5);
}