#version 450
#extension GL_EXT_nonuniform_qualifier : enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Texture index mappings
// 0 velocity
// 1 pressure
// 2 divergence
// 3 vorticity
// 4 density
// 5 temperature
layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout(binding = 2) uniform SimUBO {
    ivec3 gridSize;
} ubo;

bool isBoundary(ivec3 coord) {
    return (any(greaterThanEqual(coord, ubo.gridSize - 1)) || any(lessThanEqual(coord, ivec3(0))));
}

vec3 getVelocity(ivec3 coord) {
    return texelFetch(readOnlyTexs[0], coord, 0).xyz;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);

    const ivec3 LEFT  =  coord - ivec3(1, 0, 0);
    const ivec3 RIGHT =  coord + ivec3(1, 0, 0);
    const ivec3 DOWN  =  coord - ivec3(0, 1, 0);
    const ivec3 UP    =  coord + ivec3(0, 1, 0);
    const ivec3 BACK  =  coord - ivec3(0, 0, 1);
    const ivec3 FOR   =  coord + ivec3(0, 0, 1);

    vec3 vL = isBoundary(LEFT)  ? vec3(0) : getVelocity(LEFT);
    vec3 vR = isBoundary(RIGHT) ? vec3(0) : getVelocity(RIGHT);
    vec3 vD = isBoundary(DOWN)  ? vec3(0) : getVelocity(DOWN);
    vec3 vU = isBoundary(UP)    ? vec3(0) : getVelocity(UP);
    vec3 vB = isBoundary(BACK)  ? vec3(0) : getVelocity(BACK);
    vec3 vF = isBoundary(FOR)   ? vec3(0) : getVelocity(FOR);

    // Divide by two for derivative between 2 cells
    // e.g. (f(x + 1) - f(x)) / 2
    vec3 x = vec3(0.5f);
    float div = (x.x * (vR.x - vL.x) + x.y * (vU.y - vD.y) + x.z * (vF.z - vB.z));

    imageStore(writeOnlyTexs[2], coord, vec4(div));
}