#version 450
#extension GL_EXT_nonuniform_qualifier : enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0) uniform sampler3D readOnlyTexs[];
layout (binding = 1) uniform writeonly image3D writeOnlyTexs[];

layout(binding = 2) uniform SimParams {
    ivec3 gridSize;
    float cellSize;
} params;

// Texture index mappings
// 0 velocity
// 1 pressure
// 2 divergence
// 3 vorticity
// 4 density
// 5 temperature

bool isSolid(ivec3 coord) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, params.gridSize))) {
        return true;
    }
    return false;
}

vec3 getVelocity(ivec3 coord) {
    if (isSolid(coord)) return vec3(0.0);
    return texelFetch(readOnlyTexs[0], coord, 0).xyz;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);
    if (any(equal(coord, params.gridSize - 1)) || any(equal(coord, ivec3(0)))) return;
    
    // Skip solid cells
    if (isSolid(coord)) {
        imageStore(writeOnlyTexs[2], coord, vec4(0.0));
        return;
    }
    
    vec3 vL = getVelocity(coord - ivec3(1, 0, 0));
    vec3 vR = getVelocity(coord + ivec3(1, 0, 0));
    vec3 vD = getVelocity(coord - ivec3(0, 1, 0));
    vec3 vU = getVelocity(coord + ivec3(0, 1, 0));
    vec3 vB = getVelocity(coord - ivec3(0, 0, 1));
    vec3 vF = getVelocity(coord + ivec3(0, 0, 1));
    
    // Compute divergence
    float div = ((vR.x - vL.x) + (vU.y - vD.y) + (vF.z - vB.z)) * 
                0.5 / params.cellSize;
    
    imageStore(writeOnlyTexs[2], coord, vec4(div));
}